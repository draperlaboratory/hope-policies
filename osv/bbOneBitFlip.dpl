module osv.bbOneBitFlip:
 
/*
 * Each instr "increments" the a color (mod 3);
 * thus, the tag sequence inside a BB is Color0, Color1, Color2, Color0, Color1, etc.
 * A single bit flip w/in a BB can be detected with 3 colors as a single bit flip
 * corresponds to a change in address of +/- 2^{k}, where k (=2,31) represents
 * the bit position in the address. Thus, we need to make sure that 2^{k} (mod C) != 0,
 * where C is the number of colors. The smallest C that satisfies the eq above is 3.
 * Jumps between BBs are detected with the CFI policy and cannot be detected with 100% certainty
 * by this (simple) policy.
 */
 
import:
    osv.riscv
 
metadata:
  // color reset -- ignore the color on the next instruction
  Color-Reset

  // 3 colors for instructions
  Color0,
  Color1,
  Color2
 
policy:
    bbOneBitFlipPol = // note that order is very important here!

    // env and code should both _always_ be tagged
    allGrp (env == {} -> fail "env should always be tagged")
    ^ allGrp (code == {} -> fail "code should always be tagged")

    // if the current opcode performs some control transfer (and the color checks pass), add color reset to the env
    // this correctly handles calls, returns, and branches without needing to split up individual basic blocks
    // implicit fallthrough also doesn't need anything special now that we tag everything sequentially
    ^ controlFlowGrp (code == {Color0}, env == {Color0} -> env = {Color-Reset})
    ^ controlFlowGrp (code == {Color1}, env == {Color1} -> env = {Color-Reset})
    ^ controlFlowGrp (code == {Color2}, env == {Color2} -> env = {Color-Reset})

    // edge case: existing color reset means the color may not be valid
    ^ controlFlowGrp (env == {Color-Reset} -> env = {Color-Reset})

    // color reset handlers
    ^ allGrp (code == {Color0}, env == {Color-Reset} -> env = {Color1})
    ^ allGrp (code == {Color1}, env == {Color-Reset} -> env = {Color2})
    ^ allGrp (code == {Color2}, env == {Color-Reset} -> env = {Color0})

    // if the code and the env have the same color, update the env with the next color
    ^ allGrp (code == {Color0}, env == {Color0} -> env = {Color1})
    ^ allGrp (code == {Color1}, env == {Color1} -> env = {Color2})
    ^ allGrp (code == {Color2}, env == {Color2} -> env = {Color0})

    // we aren't resetting the color and the colors don't match! something is wrong
    ^ allGrp (-> fail "Bit flip detected")

require:
    // the first instruction to run needs a color reset but also can't be checked for a color
    // using Color-Reset in env handles that nicely for us
    init ISA.RISCV.Reg.Env                   {Color-Reset}
    init ISA.RISCV.Reg.Default               {}
    init ISA.RISCV.Reg.RZero                 {}
    init ISA.RISCV.CSR.Default               {}
    init ISA.RISCV.CSR.MTVec                 {}

    init llvm.FI_Color0                      {Color0}
    init llvm.FI_Color1                      {Color1}
    init llvm.FI_Color2                      {Color2}

    init Tools.Link.MemoryMap.Default        {}
    init Tools.Link.MemoryMap.UserHeap       {}
    init Tools.Link.MemoryMap.UserStack      {}

    init SOC.IO.UART_0                       {}
    init SOC.Memory.Flash_0                  {}
    init SOC.Memory.Ram_0                    {}

    init SOC.IO.Debug                        {}
    init SOC.IO.TEST                         {}
    init SOC.IO.CLINT                        {}
    init SOC.IO.ITIM                         {}
    init SOC.IO.PLIC                         {}

    init Tools.Elf.Section.SHF_ALLOC         {}
    init Tools.Elf.Section.SHF_EXECINSTR     {}
    init Tools.Elf.Section.SHF_WRITE         {}

    init elf.Section.SHF_ALLOC               {}
    init elf.Section.SHF_EXECINSTR           {}
    init elf.Section.SHF_WRITE               {}
