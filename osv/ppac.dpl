module osv.ppac:

import:

  osv.riscv
  osv.usr_type

metadata:

  Return-Instr

  // Actors
  Patient
  Doctor
  Admin	

  // initialzation help
  SettingP
  SettingD
  SettingA

  // current type variable
  ActiveUser

  // Protect routines
  DoctorOnly

policy:

  ppacPol =

    // explicit failures
    allGrp(code == [+DoctorOnly], env == [-Doctor] -> fail "non doctor executing doctor only routines")

    // to set the behavior, we track the call site of UserSetType and piggyback usr_type policy

        // make sure env has SettingP within set_patient function
        ^ allGrp( code == [+SettingP,+Return-Instr], env == [+SettingP] -> env = env[-SettingP] )
        ^ allGrp( code == [+SettingP], env == [-SettingP] -> env = env[+SettingP] )

	// mark mem as patient
        ^ storeGrp( code == [+Assignment], env == [+SettingP] -> mem = {Patient} )

	// propogate patient tag
   	^ loadGrp(mem == [+Patient], addr == _, env == _ -> env = env, res = mem ) 

        // same for doctor	
        ^ allGrp( code == [+SettingD,+Return-Instr], env == [+SettingD] -> env = env[-SettingD] )
        ^ allGrp( code == [+SettingD], env == [-SettingD] -> env = env[+SettingD] )
        ^ storeGrp( code == [+Assignment], env == [+SettingD] -> mem = {Doctor} )

    // set the current permission in env when new user authenticated
    ^ storeGrp(mem == [+ActiveUser], val == [+Patient] -> env = env[+Patient], mem = mem)
    ^ storeGrp(mem == [+ActiveUser], val == [+Doctor] -> env = env[+Doctor], mem = mem)

    // default: active user badge keeps its active user tag
    ^ storeGrp(mem == [+ActiveUser], val == _ -> env = env, mem = mem) 

    // all else allowed
    ^ retGrp(code == _, env == _ -> )
    ^ branchGrp(code == _, env == _, op1 == _, op2 == _ -> env = env )
    ^ jumpRegGrp(code == _, env == _, target == _ -> env = env , return = {})
    ^ jumpGrp(code == _, env == _ -> return = {})
    ^ loadUpperGrp(code == _, env == _ -> env = env, dest = {})
    ^ immArithGrp(code == _, env == _, op1 == _ -> env = env, res = {})
    ^ arithGrp(code == _, env == _, op1 == _, op2 == _ -> env = env, res = {})
    ^ loadGrp(code == _, env == _, addr == _, mem == _ -> env = env, res = {})
    ^ storeGrp(code == _, env == _, addr == _, val == _, mem == _ -> env = env, mem = {})
    ^ mulDivRemGrp(code == _, env == _, op1 == _, op2 == _ -> env = env, res = {})
    ^ csrGrp(code == _, env == _, op1 == _, csr == _ -> env = env, csr = {}, res = {})
    ^ csriGrp(code == _, env == _, csr == _ -> env = env, csr = {}, res = {})
    ^ privGrp(code == _, env == _ -> env = env)
    ^ systemGrp(code == _, env == _ -> env = env)
    ^ floatGrp(code == _, env == _ -> env = env)
    ^ atomicGrp(code == _, env == _ -> env = env)

require:
  init ISA.RISCV.Reg.Env                   {}
  init ISA.RISCV.Reg.Default               {}
  init ISA.RISCV.Reg.RZero                 {}
  init ISA.RISCV.CSR.Default               {}
  init ISA.RISCV.CSR.MTVec                 {}

  init Tools.Elf.Section.SHF_ALLOC         {}
  init Tools.Elf.Section.SHF_EXECINSTR     {}
  init Tools.Elf.Section.SHF_WRITE         {}

  init llvm.CFI_Return-Instr               {Return-Instr}

  init webapp.ppac.p_init                  {SettingP}
  init webapp.ppac.d_init                  {SettingD}

  init webapp.ppac.active                  {ActiveUser}

  init webapp.ppac.rm_treatment            {DoctorOnly}
  init webapp.ppac.add_treatment 	   {DoctorOnly}
  init webapp.ppac.rm_record               {DoctorOnly}
  init webapp.ppac.add_record    	   {DoctorOnly}