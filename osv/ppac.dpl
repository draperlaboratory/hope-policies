module osv.ppac:

import:

  osv.riscv
  osv.usr_type
  osv.heap

metadata:

  Return-Instr

  // Actors
  Patient
  Doctor
  Admin	

  // initialzation help
  SettingP
  SettingD
  SettingA

  // current type variable
  ActiveUser

  // Protect routines
  DoctorOnly

  // Protect patient data
  PatientData

policy:

  ppacPol =

    // Explicit failure for writing to Patient data without Doctor privileges
    storeGrp(mem == [+PatientData], code == [-SettingP], env == [-Doctor] -> fail "non doctor writing to patient data")

    // Apply and remove tags on patient memory
    ^ storeGrp(code == [+ApplyColor], val == [ModColor], env == [+SettingP] -> mem = {PatientData}, env = env)
    ^ storeGrp(code == [+RemoveColor], mem == [+PatientData], val == [ModColor], env == [+SettingP] -> mem = mem[-PatientData], env = env)

    // Tag patient memory, relying on User Type policy
    // 1. apply SettingP to PC to track call site inside Assignment code
    // 2. mark mem as patient
    // 3. propogate patient tag
    ^ allGrp( code == [+SettingP,+Return-Instr], env == [+SettingP] -> env = env[-SettingP] )
    ^ allGrp( code == [+SettingP], env == [-SettingP] -> env = env[+SettingP] )
    ^ storeGrp( code == [+Assignment], env == [+SettingP] -> mem = {Patient} )
   	^ loadGrp(mem == [+Patient], addr == _, env == _ -> env = env, res = mem ) 

    // Same for doctor
    ^ allGrp( code == [+SettingD,+Return-Instr], env == [+SettingD] -> env = env[-SettingD] )
    ^ allGrp( code == [+SettingD], env == [-SettingD] -> env = env[+SettingD] )
    ^ storeGrp( code == [+Assignment], env == [+SettingD] -> mem = {Doctor} )
    ^ loadGrp(mem == [+Doctor], addr == _, env == _ -> env = env, res = mem )

    // Set the current permission in env when new user authenticated
    ^ storeGrp(mem == [+ActiveUser], val == [+Patient] -> env = env[+Patient], mem = mem)
    ^ storeGrp(mem == [+ActiveUser], val == [+Doctor] -> env = env[+Doctor], mem = mem)

    // Default: active user badge keeps its active user tag
    ^ storeGrp(mem == [+ActiveUser], val == _ -> env = env, mem = mem) 

    // All else allowed
    ^ branchGrp(code == _, env == _, op1 == _, op2 == _ -> env = env )
    ^ jumpRegGrp(code == _, env == _, target == _ -> env = env , return = {})
    ^ jumpGrp(code == _, env == _ -> return = {})
    ^ loadUpperGrp(code == _, env == _ -> env = env, dest = {})
    ^ immArithGrp(code == _, env == _, op1 == _ -> env = env, res = {})
    ^ arithGrp(code == _, env == _, op1 == _, op2 == _ -> env = env, res = {})
    ^ loadGrp(code == _, env == _, addr == _, mem == _ -> env = env, res = {})
    ^ storeGrp(code == _, env == _, addr == _, val == _, mem == _ -> env = env, mem = {})
    ^ mulDivRemGrp(code == _, env == _, op1 == _, op2 == _ -> env = env, res = {})
    ^ csrGrp(code == _, env == _, op1 == _, csr == _ -> env = env, csr = {}, res = {})
    ^ csriGrp(code == _, env == _, csr == _ -> env = env, csr = {}, res = {})
    ^ privGrp(code == _, env == _ -> env = env)
    ^ systemGrp(code == _, env == _ -> env = env)
    ^ floatGrp(code == _, env == _ -> env = env)
    ^ atomicGrp(code == _, env == _ -> env = env)

require:
  init ISA.RISCV.Reg.Env                   {}
  init ISA.RISCV.Reg.Default               {}
  init ISA.RISCV.Reg.RZero                 {}
  init ISA.RISCV.CSR.Default               {}
  init ISA.RISCV.CSR.MTVec                 {}

  init Tools.Elf.Section.SHF_ALLOC         {}
  init Tools.Elf.Section.SHF_EXECINSTR     {}
  init Tools.Elf.Section.SHF_WRITE         {}

  init llvm.CFI_Return-Instr               {Return-Instr}

  init webapp.ppac.p_init                  {SettingP}
  init webapp.ppac.d_init                  {SettingD}

  init webapp.ppac.active                  {ActiveUser}

  init webapp.ppac.rm_treatment            {DoctorOnly}
  init webapp.ppac.add_treatment 	         {DoctorOnly}
  init webapp.ppac.rm_record               {DoctorOnly}
  init webapp.ppac.add_record    	         {DoctorOnly}
